---
title: 자바-10. 상속
date : 2021-06-08 12:00:00
categories: [Language, Java]
tags: [Java]
---

# extends

상속은 자식이 부모로부터 무언가는 물려받는것이다.

```java
package sample;

public class Sample4 {

	public static void main(String[] args) {
		
		Point[] p = {
						new Point(100, 100),
						new Point(140, 50),
						new Point(200, 100)
					};
		Triangle t = new Triangle(p);
		Circle c = new Circle(new Point(150, 150), 50);
		
		t.draw();  //삼각형 그리기
		c.draw();  //원그리기
	}
}

class Shape
{
	String color = "black";
	void draw()
	{
		System.out.printf("[color=%s] \n", color);
	}
}

class Point
{
	int x;
	int y;
	
	Point(int x, int y)
	{
		this.x = x;
		this.y = y;
	}
	
	Point()
	{
		this(0,0);
	}
	
	String getXY()
	{
		return "(" + x + ", " + y + ")";
	}
}

class Circle extends Shape
{
	Point center; // 인스턴스 참조형변수
	int r;
	Circle()
	{
		this(new Point(0, 0), 100);
	}
	
	Circle(Point center, int r)
	{
		this.center = center;
		this.r = r;
	}
	
	void draw()
	{
		System.out.printf("[center=%d, %d, r = %d," + "color=%s]\n", center.x, center.y, r, color);
	}
}

class Triangle extends Shape
{
	Point[] p = new Point[3];
	
	Triangle(Point[] p)
	{
		this.p = p;
	}
	
	void draw()
	{
		System.out.printf("[p1=%s, p2=%s, p3=%s," + "color=%s]\n", p[0].getXY(), p[1].getXY(), p[2].getXY(), color);
	}
}
```



이소스를 보면 크게 shape, point 클래스

shape를 상속받은 circle클래스 triangle클래스가있다.



# 오버라이딩

오버 라이딩 : 상속관계 에서 가능 
- 이름이 같아야한다.
- 매개변수가 같아야한다.
- 반환타입이 같아야한다.

오버 로딩 : 한 클래스 안에서 가능
- 생성자는 ? 오버로딩 이다.
- 매개변수와 반환타입이 달라야된다.


```java
package sample;

class Point
{
	int x;
	int y;
	
	String getLocation()
	{
		return "x : " + x + ", y : " + y;
	}
}

class Point3D extends Point
{
	int z;
	String getLocation()
	{
		return "x : " + x + ", y : " + y + ", z : " + z;
	}
	
	void getInfo()
	{
		System.out.println(getLocation());
		System.out.println(super.getLocation()); // 부모껄 쓸거야 
	}
}

public class Overriding {

	public static void main(String[] args) {
	
		Point3D p3 = new Point3D();
		p3.x = 10;
		p3.y = 20;
		System.out.println(p3.getLocation());
		System.out.println("=======================");
		p3.getInfo();
	}
}

```



# super 키워드

```java
package sample;

public class Overriding_super {

	public static void main(String[] args) {
		Child c = new Child();
		c.method(30);
	}
}

class Parent
{
	int x =10;
}

class Child extends Parent
{
	int x = 20;
	
	void method(int x)
	{
		System.out.println("x : " + x);
		System.out.println("this.x :" + this.x);	//지역
		System.out.println("super.x : " + super.x); // 부모에있는 x값이 출력된다.
													// 부모도있고 자식도 같은 변수일때 super를 사용한다.
	}
}
```

```java

public class Sample1 {
	public static void main(String[] args) {
		Point3D p3 = new Point3D(1,2,3);
	}
}

class Point
{
	int x, y;
	
	Point(int x, int y)
	{
		this.x = x;
		this.y = y;
	}
	
	String getLocation()
	{
		return "x : " + x + " , y : " + y;
	}
	
}

class Point3D extends Point
{
	int z;
	
	Point3D(int x, int y, int z) //자식입장에서부모것이 호출되면
	{
		super(x,y); // 자식입장에서 부모의생성자를 가리킬때 사용
		this.x = x;
		this.y = y;
		this.z = z;
	}
	
	String getLocation()
	{
		return "x : " + x + " , y : " + y + " , z : " + z;
		
	}
	
	void getInfo()
	{
		System.out.print(getLocation());
	}
}
```

# 접근 제어자

private : 같은 클래스 내에서만 접근가능 (은닉화) 
        : 값을 사용하려면 반드시 해당클래스의 메소드로 가져올수있다.
default : 같은 패키지 내에서만 접근 가능
protected : 같은 패키지 내에서와 다른 패키지의 자손 클래스에서 접근 가능
public : 접근제한이 없음


클래스 : public, default
메서드, 멤버변수 : public, protected (default), private
지역변수 : 없음


private < default(같은패키지) < protected(같은패키지, 다른패키지 상속) < public


# 다형성

부모클래스 타입의 참조변수로 자식 클래스 타입의 인스턴스를 참조 할수있도록 구현한것

부모  = 자식 순은된다.
Parent pc = new Child() -> 허용

자식 = 부모 순은되지않는다.



자식클래스에서 사용할수있는 멤버 개수가 언제나 부모클래스와 같거나 많게된다. 

자식(멤버개수) > 부모(맴버개수)

참조변수 instanceof 클래스이름 -> 같으면 true, false리턴

```java
package sample;

public class sample1 {

	public static void main(String[] args) {
		// 다형성
		Car car = null;
		FireEngine fe = new FireEngine();
		FireEngine fe2 = null;
		
		fe.water();
		car = fe; // 엄마주소 = 자식주소
		//car.water();
		fe2 = (FireEngine)car;
		fe2.water();
	}

}

class Car
{
	String color;
	int door;
	
	void drive()
	{
		System.out.println("drive, .....");
	}
	
	void stop()
	{
		System.out.println("stop.....");
	}
}

class FireEngine extends Car
{
	void water()
	{
		System.out.println("water() ......");
	}
}

```

```java
package sample;

public class sample1 {

	public static void main(String[] args) {
		// 다형성
		/*
		Car car = null; // 지역변수라 초기화 
		FireEngine fe = new FireEngine();
		FireEngine fe2 = null;
		
		fe.water();
		car = fe; // 엄마 인스턴스 = 참조형 타입이 탈라
				//	같은주소를 바라본다)
		
		//Car car = new FireEngine(); -> 이것을 생각하자 
		//car.water(); 참조는 하되 접근할수는 없다. 자식이 더많으니까 다 상속받을수없기 때문에, 따라서 형변환을 해줘야 가능하다  
		fe2 = (FireEngine)car; 			//자식 인스턴스 = (클래스)엄마
		fe2.water(); // 				//형변환가능 
		*/
		
		
		Car car = new FireEngine();
		Car car2 = null;
		FireEngine fe = null;
		FireEngine fe2 = null;
		
		car.drive();
		fe = (FireEngine)car; // 5평 4평	
	
		
		fe.drive();
		car2 = fe;
		car2.drive();
	}
}

class Car
{
	String color;
	int door;

	void drive()
	{
		System.out.println("drive, .....");
	}
	
	void stop()
	{
		System.out.println("stop.....");
	}
}

class FireEngine extends Car
{
	void water()
	{
		System.out.println("water() ......");
	}
}

```


# instanceof

참조변수가 참조하고 있는 인스턴스의 실제 타입을 알아보기 위해 instanceof 연산자를 사용























```
