---
title: 자바-10. 상속
date : 2021-06-08 12:00:00
categories: [Language, Java]
tags: [Java]
---

# extends

상속은 자식이 부모로부터 무언가는 물려받는것이다.

```java
package sample;

public class Sample4 {

	public static void main(String[] args) {
		
		Point[] p = {
						new Point(100, 100),
						new Point(140, 50),
						new Point(200, 100)
					};
		Triangle t = new Triangle(p);
		Circle c = new Circle(new Point(150, 150), 50);
		
		t.draw();  //삼각형 그리기
		c.draw();  //원그리기
	}
}

class Shape
{
	String color = "black";
	void draw()
	{
		System.out.printf("[color=%s] \n", color);
	}
}

class Point
{
	int x;
	int y;
	
	Point(int x, int y)
	{
		this.x = x;
		this.y = y;
	}
	
	Point()
	{
		this(0,0);
	}
	
	String getXY()
	{
		return "(" + x + ", " + y + ")";
	}
}

class Circle extends Shape
{
	Point center; // 인스턴스 참조형변수
	int r;
	Circle()
	{
		this(new Point(0, 0), 100);
	}
	
	Circle(Point center, int r)
	{
		this.center = center;
		this.r = r;
	}
	
	void draw()
	{
		System.out.printf("[center=%d, %d, r = %d," + "color=%s]\n", center.x, center.y, r, color);
	}
}

class Triangle extends Shape
{
	Point[] p = new Point[3];
	
	Triangle(Point[] p)
	{
		this.p = p;
	}
	
	void draw()
	{
		System.out.printf("[p1=%s, p2=%s, p3=%s," + "color=%s]\n", p[0].getXY(), p[1].getXY(), p[2].getXY(), color);
	}
}
```



이소스를 보면 크게 shape, point 클래스

shape를 상속받은 circle클래스 triangle클래스가있다.



# 오버라이딩

오버라이딩 : 상속관계에서 가능하다  VS 오버로딩 : 클래스에서 가능하다

- 이름이 같아야한다.
- 매개변수가 같아야한다.
- 반환타입이 같아야한다.

```java
package sample;

class Point
{
	int x;
	int y;
	
	String getLocation()
	{
		return "x : " + x + ", y : " + y;
	}
}

class Point3D extends Point
{
	int z;
	String getLocation()
	{
		return "x : " + x + ", y : " + y + ", z : " + z;
	}
	
	void getInfo()
	{
		System.out.println(getLocation());
		System.out.println(super.getLocation()); // 부모껄 쓸거야 
	}
}

public class Overriding {

	public static void main(String[] args) {
	
		Point3D p3 = new Point3D();
		p3.x = 10;
		p3.y = 20;
		System.out.println(p3.getLocation());
		System.out.println("=======================");
		p3.getInfo();
	}
}

```



# super 키워드

```java
package sample;

public class Overriding_super {

	public static void main(String[] args) {
		Child c = new Child();
		c.method(30);
	}
}

class Parent
{
	int x =10;
}

class Child extends Parent
{
	int x = 20;
	
	void method(int x)
	{
		System.out.println("x : " + x);
		System.out.println("this.x :" + this.x);	//지역
		System.out.println("super.x : " + super.x); // 부모에있는 x값이 출력된다.
													// 부모도있고 자식도 같은 변수일때 super를 사용한다.
	}
}
```

```java

public class Sample1 {
	public static void main(String[] args) {
		Point3D p3 = new Point3D(1,2,3);
	}
}

class Point
{
	int x, y;
	
	Point(int x, int y)
	{
		this.x = x;
		this.y = y;
	}
	
	String getLocation()
	{
		return "x : " + x + " , y : " + y;
	}
	
}

class Point3D extends Point
{
	int z;
	
	Point3D(int x, int y, int z) //자식입장에서부모것이 호출되면
	{
		super(x,y); // 자식입장에서 부모의생성자를 가리킬때 사용
		this.x = x;
		this.y = y;
		this.z = z;
	}
	
	String getLocation()
	{
		return "x : " + x + " , y : " + y + " , z : " + z;
		
	}
	
	void getInfo()
	{
		System.out.print(getLocation());
	}
}
```

# 접근 제어자

private : 같은 클래스 내에서만 접근가능 (은닉화) 
        : 값을 사용하려면 반드시 해당클래스의 메소드로 가져올수있다.
default : 같은 패키지 내에서만 접근 가능
protected : 같은 패키지 내에서와 다른 패키지의 자손 클래스에서 접근 가능
public : 접근제한이 없음


클래스 : public, default
메서드, 멤버변수 : public, protected default, private
지역변수 : 없음


private < default(같은패키지) < protected(같은패키지, 다른패키지 상속) < public






























```
